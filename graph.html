<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Skills Knowledge Graph</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --color-lean: #FF6B6B;
            --color-wild: #4ECDC4;
            --color-looks: #FFE66D;
            --color-psych: #A78BFA;
            --color-health: #F87171;
            --color-friends: #34D399;
            --color-bg: #0a0a0f;
            --color-text: #ffffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            color: var(--color-text);
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                repeating-linear-gradient(
                    0deg,
                    rgba(255, 255, 255, 0.08) 0px,
                    transparent 1px,
                    transparent 2px,
                    rgba(255, 255, 255, 0.08) 3px
                ),
                url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJhIiB4PSIwIiB5PSIwIj48ZmVUdXJidWxlbmNlIGJhc2VGcmVxdWVuY3k9Ii43NSIgc3RpdGNoVGlsZXM9InN0aXRjaCIgdHlwZT0iZnJhY3RhbE5vaXNlIi8+PGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIvPjwvZmlsdGVyPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbHRlcj0idXJsKCNhKSIgb3BhY2l0eT0iMC4xNSIvPjwvc3ZnPg==');
            background-size: 100% 100%, 120px 120px;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.65;
            mix-blend-mode: overlay;
            animation: grain 0.12s steps(6) infinite;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at center, transparent 0%, rgba(0, 0, 0, 0.6) 100%),
                repeating-linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0.02) 0px,
                    transparent 2px,
                    transparent 4px,
                    rgba(255, 255, 255, 0.02) 6px
                );
            pointer-events: none;
            z-index: 1;
        }

        @keyframes grain {
            0%, 100% { transform: translate(0, 0); opacity: 0.65; }
            10% { transform: translate(-8%, -8%); opacity: 0.7; }
            20% { transform: translate(-15%, 8%); opacity: 0.6; }
            30% { transform: translate(8%, -15%); opacity: 0.75; }
            40% { transform: translate(-8%, 20%); opacity: 0.65; }
            50% { transform: translate(-15%, 8%); opacity: 0.7; }
            60% { transform: translate(20%, 0); opacity: 0.65; }
            70% { transform: translate(0, 15%); opacity: 0.7; }
            80% { transform: translate(-20%, 0); opacity: 0.65; }
            90% { transform: translate(15%, 8%); opacity: 0.7; }
        }

        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .view {
            display: none;
            width: 100%;
            height: 100%;
        }

        .view.active {
            display: block;
        }

        /* Graph View */
        #graph-view {
            position: relative;
            z-index: 10;
        }

        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
            filter: contrast(1.05) brightness(0.98);
        }

        svg:active {
            cursor: grabbing;
        }

        #graph-svg::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 200px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        .link {
            stroke: #4ECDC4;
            stroke-opacity: 0.15;
            fill: none;
        }

        .node circle {
            stroke: none;
            cursor: pointer;
        }

        .node text {
            font-size: 10px;
            font-weight: 400;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            stroke: none;
            stroke-width: 0;
        }


        /* Energy particles */
        .particle {
            fill: #4ECDC4;
            opacity: 0.5;
        }

        /* Table View */
        #table-view {
            overflow-y: auto;
            padding: 40px;
        }

        .table-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .table-header {
            margin-bottom: 30px;
            text-align: center;
        }

        .table-header h1 {
            font-family: 'Share Tech Mono', monospace;
            font-size: 32px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--color-lean), var(--color-wild), var(--color-looks));
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--color-wild);
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.6;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            font-family: 'Share Tech Mono', monospace;
            font-size: 24px;
            margin-bottom: 20px;
            color: var(--color-wild);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            overflow: hidden;
        }

        thead {
            background: rgba(255, 255, 255, 0.08);
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        td {
            padding: 12px 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 13px;
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            box-shadow: 0 0 8px currentColor;
        }

        .no-connections {
            opacity: 0.5;
            background: rgba(255, 100, 100, 0.1);
        }

        .no-connections-badge {
            display: inline-block;
            background: rgba(255, 100, 100, 0.3);
            color: #ff6b6b;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-left: 8px;
        }

        /* Toggle Button */
        .toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Share Tech Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.3s;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .legend-title {
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 15px;
            opacity: 0.6;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-size: 13px;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-item.dimmed {
            opacity: 0.3;
        }

        .legend-icon {
            font-size: 18px;
            margin-right: 10px;
            filter: drop-shadow(0 0 4px currentColor);
        }


        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(20px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 300px;
            font-size: 12px;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip h3 {
            font-size: 13px;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .tooltip p {
            margin-bottom: 8px;
            opacity: 0.8;
            line-height: 1.5;
        }

        .tooltip .connections {
            font-size: 11px;
            opacity: 0.6;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
        }

        .loading.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            margin: 0 auto 20px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--color-wild);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .filter-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        select, input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
        }

        select option {
            background: #1a1a2e;
        }
    </style>
</head>
<body>
    <div id="app">
        <a href="index.html" class="toggle-btn" style="right: 170px; text-decoration: none;">Activity Builder</a>
        <button class="toggle-btn" onclick="toggleView()">
            <span id="toggle-text">Show Table</span>
        </button>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>Loading Graph...</div>
        </div>

        <!-- Graph View -->
        <div id="graph-view" class="view active">
            <svg id="graph-svg"></svg>
            <div class="legend" id="legend"></div>
            <div class="tooltip" id="tooltip"></div>
        </div>

        <!-- Table View -->
        <div id="table-view" class="view">
            <div class="table-container">
                <div class="table-header">
                    <h1>Life Skills Knowledge Graph</h1>
                </div>

                <div class="stats-grid" id="stats"></div>

                <div class="section">
                    <h2>All Topics by Course</h2>
                    <div class="filter-controls">
                        <select id="course-filter" onchange="filterTable()">
                            <option value="all">All Courses</option>
                        </select>
                        <input type="text" id="search-input" placeholder="Search topics..." oninput="filterTable()">
                    </div>
                    <table id="topics-table">
                        <thead>
                            <tr>
                                <th>Course</th>
                                <th>Topic</th>
                                <th>Description</th>
                                <th>Connections</th>
                                <th>Total Strength</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>

                <div class="section">
                    <h2>Relationships</h2>
                    <div class="filter-controls">
                        <select id="strength-filter" onchange="filterRelationships()">
                            <option value="0">All Strengths</option>
                            <option value="7">Strong (7+)</option>
                            <option value="9">Very Strong (9+)</option>
                        </select>
                    </div>
                    <table id="relationships-table">
                        <thead>
                            <tr>
                                <th>From</th>
                                <th>To</th>
                                <th>Strength</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        let data = null;
        let simulation = null;
        let currentView = 'graph';
        let minStrength = 7; // Fixed strength filter
        let activeCourses = new Set();
        let graphElements = {};
        let rotationAngle = 0;

        const SUPABASE_URL = 'https://aeusujfuxnxwbvccmusk.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFldXN1amZ1eG54d2J2Y2NtdXNrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE5MDAwNDAsImV4cCI6MjA1NzQ3NjA0MH0.rMuOA4LyVVao4_alpNopj2E4mpzEHYxBOMJxv6jrOVA';
        const HEADERS = {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
        };

        // Default fallback colors and icons for courses without them
        const DEFAULT_COLORS = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#A78BFA', '#F87171', '#34D399', '#60A5FA', '#FB923C'];
        const AREA_ICONS = {
            'Tech Basement': 'ðŸ’»',
            'Wealth Vault': 'ðŸ’°',
            'Wellbeing Garden': 'ðŸŒ¿',
            'Relationship Campsite': 'ðŸ•ï¸',
            'Business Lounge': 'ðŸ’¼',
            'Communication Atrium': 'ðŸ—£ï¸',
            "Artisan's Atelier": 'ðŸŽ¨',
            'Culture Salon': 'ðŸ“š'
        };
        const DEFAULT_ICON = 'ðŸ“Œ';

        let colorMap = {};
        let iconMap = {};

        // Toggle between views
        function toggleView() {
            currentView = currentView === 'graph' ? 'table' : 'graph';
            document.getElementById('graph-view').classList.toggle('active');
            document.getElementById('table-view').classList.toggle('active');
            document.getElementById('toggle-text').textContent =
                currentView === 'graph' ? 'Show Table' : 'Show Graph';

            if (currentView === 'graph' && simulation) {
                simulation.alpha(0.3).restart();
            }
        }

        // Fetch a Supabase table
        async function fetchTable(table, query = '') {
            const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}?${query}`, { headers: HEADERS });
            if (!res.ok) throw new Error(`Failed to fetch ${table}: ${res.status}`);
            return res.json();
        }

        // Load and initialize
        async function init() {
            try {
                console.log('Starting init...');

                // Fetch all tables in parallel
                const [areas, courses, levels, topics, topicLinks] = await Promise.all([
                    fetchTable('areas', 'select=id,title,order_number&order=order_number'),
                    fetchTable('courses', 'select=id,title,color,status,area_id'),
                    fetchTable('levels', 'select=id,course_id'),
                    fetchTable('topics', 'select=id,level_id,title'),
                    fetchTable('topic_links', 'select=topic_a_id,topic_b_id,strength')
                        .catch(() => []) // table may not exist yet
                ]);

                console.log('Fetched:', areas.length, 'areas,', courses.length, 'courses,', topics.length, 'topics,', topicLinks.length, 'topic_links');

                // Build lookups
                const levelToCourse = {};
                levels.forEach(l => { levelToCourse[l.id] = l.course_id; });

                const courseById = {};
                courses.forEach(c => { courseById[c.id] = c; });

                // Build colorMap and iconMap keyed by area id
                areas.forEach((a, i) => {
                    colorMap[a.id] = DEFAULT_COLORS[i % DEFAULT_COLORS.length];
                    iconMap[a.id] = AREA_ICONS[a.title] || DEFAULT_ICON;
                });

                // Transform areas for legend
                const transformedAreas = areas.map(a => ({
                    id: a.id,
                    name: a.title,
                    color: colorMap[a.id]
                }));

                // Transform topics (join through levels + courses to get areaId)
                const transformedTopics = topics.map(t => {
                    const courseId = levelToCourse[t.level_id];
                    const course = courseId ? courseById[courseId] : null;
                    return {
                        id: t.id,
                        courseId: courseId,
                        courseName: course ? course.title : '',
                        areaId: course ? course.area_id : null,
                        name: t.title,
                        description: '',
                        totalConnectionStrength: 0,
                        connectionCount: 0
                    };
                }).filter(t => t.courseId && t.areaId); // skip orphans

                // Build topic lookup for relationship generation
                const topicById = {};
                transformedTopics.forEach(t => { topicById[t.id] = t; });

                // Explicit relationships from topic_links (strength 0-1 scaled to 1-10)
                // Boost same-course links by +2 (0.2 on 0-1 scale) so they cluster together
                const relationships = topicLinks.map(l => {
                    const src = topicById[l.topic_a_id];
                    const tgt = topicById[l.topic_b_id];
                    const sameCourse = src && tgt && src.courseId === tgt.courseId;
                    return {
                        source: l.topic_a_id,
                        target: l.topic_b_id,
                        strength: Math.min(10, Math.round(l.strength * 10) + (sameCourse ? 2 : 0)),
                        reason: ''
                    };
                }).filter(r => topicById[r.source] && topicById[r.target]);

                // Calculate connectionCount and totalConnectionStrength per topic
                relationships.forEach(r => {
                    if (topicById[r.source]) {
                        topicById[r.source].connectionCount++;
                        topicById[r.source].totalConnectionStrength += r.strength;
                    }
                    if (topicById[r.target]) {
                        topicById[r.target].connectionCount++;
                        topicById[r.target].totalConnectionStrength += r.strength;
                    }
                });

                data = {
                    areas: transformedAreas,
                    topics: transformedTopics,
                    relationships: relationships
                };

                console.log('Data transformed:', data.topics.length, 'topics,', data.relationships.length, 'relationships');

                initGraph();
                initTable();

                document.getElementById('loading').classList.add('hidden');
                console.log('Loading complete');
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = '<div>Error: ' + error.message + '</div>';
            }
        }

        function initGraph() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            const svg = d3.select('#graph-svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g').attr('class', 'zoom-container');
            const rotationContainer = g.append('g').attr('class', 'rotation-container');

            // Zoom and pan - start zoomed out
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Initialize all areas as active
            data.areas.forEach(a => activeCourses.add(a.id));

            // Filter out nodes with ZERO connections completely - don't even add them to the graph
            const nodes = data.topics.filter(d => (d.connectionCount || 0) > 0).map(d => ({...d}));

            // Create links data - filter by strength AND hide connections to nodes with 0 connections
            const allLinks = data.relationships.filter(d => {
                const sourceNode = nodes.find(t => t.id === d.source);
                const targetNode = nodes.find(t => t.id === d.target);
                return sourceNode && targetNode; // Only include if both nodes exist
            }).map(d => ({...d}));

            const links = allLinks.filter(d => {
                const sourceNode = nodes.find(t => t.id === d.source);
                const targetNode = nodes.find(t => t.id === d.target);
                return d.strength >= minStrength && sourceNode && targetNode;
            });

            // Function to center view on visible nodes
            function centerOnNodes(duration = 1000) {
                // Filter nodes that are actually visible (in active course)
                const filteredLinks = allLinks.filter(d => {
                    const sourceNode = nodes.find(t => t.id === d.source.id || t.id === d.source);
                    const targetNode = nodes.find(t => t.id === d.target.id || t.id === d.target);
                    return d.strength >= minStrength &&
                           sourceNode &&
                           targetNode &&
                           activeCourses.has(sourceNode.areaId) &&
                           activeCourses.has(targetNode.areaId);
                });

                const activeConnectionCounts = {};
                nodes.forEach(n => activeConnectionCounts[n.id] = 0);
                filteredLinks.forEach(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    activeConnectionCounts[sourceId] = (activeConnectionCounts[sourceId] || 0) + 1;
                    activeConnectionCounts[targetId] = (activeConnectionCounts[targetId] || 0) + 1;
                });

                const visibleNodes = nodes.filter(n => {
                    return activeCourses.has(n.areaId) && (activeConnectionCounts[n.id] || 0) > 0;
                });

                if (visibleNodes.length === 0) return;

                // Calculate bounding box using display positions if available
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                visibleNodes.forEach(n => {
                    const x = n.displayX || n.targetX || n.x;
                    const y = n.displayY || n.targetY || n.y;
                    const radius = n.radius || 18;
                    minX = Math.min(minX, x - radius);
                    minY = Math.min(minY, y - radius);
                    maxX = Math.max(maxX, x + radius);
                    maxY = Math.max(maxY, y + radius);
                });

                // Add padding
                const padding = 120;
                minX -= padding;
                minY -= padding;
                maxX += padding;
                maxY += padding;

                // Calculate center and scale
                const boxWidth = maxX - minX;
                const boxHeight = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                const scale = Math.min(
                    width / boxWidth,
                    height / boxHeight,
                    2.5 // Max zoom in
                );

                // Calculate transform
                const transform = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(Math.max(0.3, scale * 0.85)) // 85% to add more breathing room, min 0.3
                    .translate(-centerX, -centerY);

                // Apply transform smoothly
                svg.transition()
                    .duration(duration)
                    .ease(d3.easeCubicInOut)
                    .call(zoom.transform, transform);
            }

            // Store centerOnNodes globally
            window.centerOnNodes = centerOnNodes;

            // Start with a zoomed out view, then center after initial layout
            svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(0.5).translate(-width / 2, -height / 2));

            // Center on nodes after unfold animation completes
            setTimeout(() => {
                centerOnNodes(1500);
            }, 3500);

            // Create force simulation with MUCH more spacing and organic flow
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => 250 - (d.strength * 15)) // Much larger base distance
                    .strength(d => d.strength / 20) // Weaker springs for more organic feel
                )
                .force('charge', d3.forceManyBody().strength(-1500)) // Much stronger repulsion
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => (d.radius || 18) + 15)) // Variable collision based on node size
                .alphaDecay(0.005) // Much slower decay for more organic movement
                .velocityDecay(0.4); // More damping for fluid motion

            // Create links
            const link = rotationContainer.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('class', 'link')
                .attr('stroke-width', d => d.strength / 3)
                .attr('stroke-opacity', 0); // Start invisible

            // Create energy particles (very minimal for performance)
            const particleData = [];
            links.forEach((link, idx) => {
                // Only add particles to every 5th connection to reduce load
                if (idx % 5 === 0) {
                    const count = 1; // Just one particle per link for performance
                    for (let i = 0; i < count; i++) {
                        particleData.push({
                            link: link,
                            offset: Math.random(),
                            speed: 0.0008 + Math.random() * 0.0005
                        });
                    }
                }
            });

            const particles = rotationContainer.append('g')
                .selectAll('circle')
                .data(particleData)
                .join('circle')
                .attr('class', 'particle')
                .attr('r', 2.5)
                .attr('opacity', 0); // Start invisible

            // Store connection data globally for filtering (now from database)
            const connectionCounts = {};
            nodes.forEach(n => connectionCounts[n.id] = n.connectionCount || 0);
            window.totalConnectionCounts = connectionCounts;

            // Run simulation silently to calculate positions (reduced for performance)
            for (let i = 0; i < 200; i++) {
                simulation.tick();
            }

            // Store calculated positions and reset to center
            nodes.forEach(node => {
                // Variable size based on connection count (1-8 range, map to radius 6-50)
                const count = node.connectionCount || 1;
                node.radius = 6 + Math.pow(count, 1.5) * 3;

                node.targetX = node.x;
                node.targetY = node.y;
                node.x = width / 2;
                node.y = height / 2;
                node.displayX = width / 2;
                node.displayY = height / 2;
                node.organicPhase = Math.random() * Math.PI * 2;
                node.organicSpeed = 0.5 + Math.random() * 0.4;
                // Bigger nodes move less (more mass)
                node.organicAmplitude = Math.max(12, 22 - (node.radius / 4));
            });

            // Restart simulation with positions reset
            simulation.alpha(0.3).restart();

            // Create 3D sphere gradients for each node
            const defs = svg.append('defs');
            nodes.forEach(node => {
                const gradient = defs.append('radialGradient')
                    .attr('id', `sphere-gradient-${node.id}`)
                    .attr('cx', '30%')
                    .attr('cy', '30%');

                const baseColor = d3.color(colorMap[node.areaId]);
                const highlightColor = baseColor.brighter(1.8);
                const midColor = baseColor.brighter(0.3);
                const shadowColor = baseColor.darker(1.2);

                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', highlightColor);

                gradient.append('stop')
                    .attr('offset', '40%')
                    .attr('stop-color', midColor);

                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', shadowColor);
            });

            // Create nodes
            const node = rotationContainer.append('g')
                .selectAll('g')
                .data(nodes)
                .join('g')
                .attr('class', 'node')
                .call(drag(simulation));

            // Add glow layer (double the radius, brightness based on size)
            // Using multiple circles for performance instead of expensive blur filter
            for (let i = 0; i < 3; i++) {
                node.append('circle')
                    .attr('class', 'node-glow')
                    .attr('r', d => (d.radius || 18) * (1.4 + i * 0.3))
                    .attr('fill', d => colorMap[d.areaId])
                    .attr('opacity', d => {
                        // Subtle glow - reduced opacity
                        const sizeRatio = (d.radius - 12) / 28;
                        const baseOpacity = 0.12 + (sizeRatio * 0.08);
                        return baseOpacity / (i + 1.5);
                    });
            }

            // Add main sphere
            node.append('circle')
                .attr('class', 'node-sphere')
                .attr('r', d => d.radius || 18)
                .attr('fill', d => `url(#sphere-gradient-${d.id})`)
                .on('click', function(event) {
                    // Prevent any click interference - nodes should never hide on click
                    event.stopPropagation();
                })
                .on('mouseenter', function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(300)
                        .attr('r', (d.radius || 18) * 1.2);
                    // Also expand all glow layers on hover with slightly increased opacity
                    d3.select(this.parentNode).selectAll('.node-glow')
                        .transition()
                        .duration(300)
                        .attr('r', (gd, i) => (d.radius || 18) * (1.7 + i * 0.35))
                        .attr('opacity', (gd, i) => {
                            const sizeRatio = (d.radius - 12) / 28;
                            const baseOpacity = 0.18 + (sizeRatio * 0.12);
                            return baseOpacity / (i + 1.5);
                        });
                    showTooltip(event, d);
                })
                .on('mouseleave', function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(300)
                        .attr('r', d.radius || 18);
                    // Restore all glow layers with subtle opacity
                    d3.select(this.parentNode).selectAll('.node-glow')
                        .transition()
                        .duration(300)
                        .attr('r', (gd, i) => (d.radius || 18) * (1.4 + i * 0.3))
                        .attr('opacity', (gd, i) => {
                            const sizeRatio = (d.radius - 12) / 28;
                            const baseOpacity = 0.12 + (sizeRatio * 0.08);
                            return baseOpacity / (i + 1.5);
                        });
                    hideTooltip();
                });

            node.append('text')
                .attr('dy', d => (d.radius || 18) + 12)
                .text(d => d.name)
                .style('font-size', '10px')
                .attr('class', 'node-label')
                .attr('stroke', 'none')
                .attr('stroke-width', 0)
                .attr('fill', d => {
                    // Make a VERY pale version of the node color - almost white with just a hint
                    const baseColor = d3.color(colorMap[d.areaId]);
                    const hsl = d3.hsl(baseColor);
                    hsl.l = 0.92; // Very close to white
                    hsl.s = 0.3;  // Low saturation for just a hint of color
                    return hsl.toString();
                });

            // All nodes already filtered to have connections, no need to hide any
            // Store references for filtering
            graphElements = { link, particles, node, g, rotationContainer, allLinks, svg, zoom };

            // Optimized animation loop with smooth unfold and organic movement
            let animationTime = 0;
            const UNFOLD_DURATION = 3000; // 3 seconds smooth unfold
            const FADE_START = 1500; // Start fading in connections at 1.5s
            let animationFrame = 0;
            let frameCounter = 0;

            function animate() {
                animationFrame = requestAnimationFrame(animate);
                animationTime += 16;
                frameCounter++;

                const unfoldProgress = Math.min(animationTime / UNFOLD_DURATION, 1);
                const easeProgress = easeOutCubic(unfoldProgress);

                // Subtle screen rotation (update only every 2nd frame for performance)
                if (unfoldProgress >= 1 && frameCounter % 2 === 0) {
                    rotationAngle += 0.015;
                    rotationContainer.attr('transform', `rotate(${Math.sin(rotationAngle) * 2.5})`);
                }

                // Update node positions with unfold animation
                const time = animationTime * 0.001;
                nodes.forEach(d => {
                    if (unfoldProgress < 1) {
                        const centerX = width / 2;
                        const centerY = height / 2;
                        d.displayX = centerX + (d.targetX - centerX) * easeProgress;
                        d.displayY = centerY + (d.targetY - centerY) * easeProgress;
                    } else {
                        // After unfold, add organic floating movement
                        const offsetX = Math.sin(time * d.organicSpeed + d.organicPhase) * d.organicAmplitude;
                        const offsetY = Math.cos(time * d.organicSpeed * 0.7 + d.organicPhase) * d.organicAmplitude;
                        d.displayX = d.targetX + offsetX;
                        d.displayY = d.targetY + offsetY;
                    }
                });

                // Update link positions
                link
                    .attr('x1', d => d.source.displayX)
                    .attr('y1', d => d.source.displayY)
                    .attr('x2', d => d.target.displayX)
                    .attr('y2', d => d.target.displayY);

                // Fade in connections smoothly (only during transition)
                if (animationTime > FADE_START && unfoldProgress < 1) {
                    const fadeProgress = Math.min((animationTime - FADE_START) / 2000, 1);
                    const eased = easeOutCubic(fadeProgress);
                    link.attr('stroke-opacity', eased * 0.15);
                } else if (unfoldProgress >= 1 && animationTime < UNFOLD_DURATION + 2000) {
                    link.attr('stroke-opacity', 0.15);
                }

                // Update node transforms
                node.attr('transform', d => `translate(${d.displayX},${d.displayY})`);

                // Update particles (only every 3rd frame for performance)
                if (frameCounter % 3 === 0) {
                    particles.each(function(d) {
                        d.offset = (d.offset + d.speed * 3) % 1; // Compensate for skipped frames
                    });

                    particles
                        .attr('cx', d => {
                            const source = d.link.source;
                            const target = d.link.target;
                            return source.displayX + (target.displayX - source.displayX) * d.offset;
                        })
                        .attr('cy', d => {
                            const source = d.link.source;
                            const target = d.link.target;
                            return source.displayY + (target.displayY - source.displayY) * d.offset;
                        });
                }

                // Set particle opacity once after fade-in completes
                if (animationTime === UNFOLD_DURATION + 2000 || (animationTime > UNFOLD_DURATION + 2000 && animationTime < UNFOLD_DURATION + 2016)) {
                    particles.attr('opacity', 0.5);
                }
            }

            function easeOutCubic(x) {
                return 1 - Math.pow(1 - x, 3);
            }

            // Start animation loop
            animate();

            // Store nodes globally for filter updates
            window.graphNodes = nodes;

            // Stop simulation after initial layout to save performance
            // Display is handled by animate() loop, physics only needed during drag
            setTimeout(() => {
                if (simulation.alpha() < 0.05) {
                    simulation.stop();
                }
            }, 5000);

            // Keep simulation ticking during initial layout
            simulation.on('tick', () => {
                // Physics calculation happens here, display happens in animate()
                // After initial layout, simulation will be stopped for performance
            });

            // Create legend with click filtering
            const legend = d3.select('#legend');

            // Add title
            legend.append('div')
                .attr('class', 'legend-title')
                .text('AREAS');

            // Add area items
            data.areas.forEach(area => {
                legend.append('div')
                    .attr('class', 'legend-item')
                    .attr('data-course', area.id)
                    .html(`
                        <span class="legend-icon" style="color: ${area.color};">${iconMap[area.id]}</span>
                        <span>${area.name}</span>
                    `)
                    .on('click', () => toggleCourse(area.id));
            });

            // Tooltip functions
            const tooltip = d3.select('#tooltip');

            function showTooltip(event, d) {
                const area = data.areas.find(a => a.id === d.areaId);
                const connections = d.connectionCount || 0;
                const totalStrength = d.totalConnectionStrength || 0;

                tooltip
                    .style('left', (event.pageX + 15) + 'px')
                    .style('top', (event.pageY + 15) + 'px')
                    .html(`
                        <h3>${d.name}</h3>
                        <p style="opacity:0.6; font-size:11px;">${d.courseName}</p>
                        <div class="connections">${connections} connections</div>
                    `)
                    .classed('visible', true);
            }

            function hideTooltip() {
                tooltip.classed('visible', false);
            }

            // Optimized drag behavior - nodes float back to physics position after release
            function drag(simulation) {
                function dragstarted(event) {
                    // Restart simulation for drag interaction
                    simulation.alpha(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    // Only constrain physics position, not display target
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }

                function dragended(event) {
                    // Release physics constraints - node will float back to equilibrium
                    event.subject.fx = null;
                    event.subject.fy = null;

                    // Keep simulation active briefly to find new equilibrium
                    simulation.alpha(0.3);

                    // After simulation settles, update target and stop simulation for performance
                    setTimeout(() => {
                        event.subject.targetX = event.subject.x;
                        event.subject.targetY = event.subject.y;
                        simulation.alpha(0);

                        // Stop simulation again to save performance
                        setTimeout(() => simulation.stop(), 100);
                    }, 1500);
                }

                return d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended);
            }

            // Handle resize with smooth transition
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    const newWidth = window.innerWidth;
                    const newHeight = window.innerHeight;
                    svg.attr('width', newWidth).attr('height', newHeight);
                    simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));

                    // Store old targets
                    const oldTargets = new Map();
                    nodes.forEach(n => {
                        oldTargets.set(n.id, { x: n.targetX, y: n.targetY });
                    });

                    // Recalculate target positions
                    simulation.alpha(0.5);
                    for (let i = 0; i < 150; i++) {
                        simulation.tick();
                    }

                    // Smooth transition to new positions
                    nodes.forEach(n => {
                        const old = oldTargets.get(n.id);
                        const newTargetX = n.x;
                        const newTargetY = n.y;

                        n.targetX = old.x;
                        n.targetY = old.y;

                        const duration = 1500;
                        const startTime = Date.now();

                        function transitionPosition() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            const eased = easeInOutCubic(progress);

                            n.targetX = old.x + (newTargetX - old.x) * eased;
                            n.targetY = old.y + (newTargetY - old.y) * eased;

                            if (progress < 1) {
                                requestAnimationFrame(transitionPosition);
                            }
                        }
                        transitionPosition();
                    });

                    simulation.alpha(0.1).restart();

                    // Recenter after resize
                    setTimeout(() => {
                        if (window.centerOnNodes) {
                            window.centerOnNodes(1000);
                        }
                    }, 500);
                }, 250);
            });
        }

        function initTable() {
            // Stats - use database values
            const stats = document.getElementById('stats');
            const totalTopics = data.topics.length;
            const topicsWithConnections = data.topics.filter(t => t.connectionCount > 0).length;

            stats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${data.areas.length}</div>
                    <div class="stat-label">Areas</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalTopics}</div>
                    <div class="stat-label">Total Topics</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${topicsWithConnections}</div>
                    <div class="stat-label">Connected Topics</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${data.relationships.length}</div>
                    <div class="stat-label">Connections</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${(data.relationships.reduce((sum, r) => sum + r.strength, 0) / data.relationships.length).toFixed(1)}</div>
                    <div class="stat-label">Avg Strength</div>
                </div>
            `;

            // Area filter
            const courseFilter = document.getElementById('course-filter');
            data.areas.forEach(area => {
                const option = document.createElement('option');
                option.value = area.id;
                option.textContent = area.name;
                courseFilter.appendChild(option);
            });

            // Topics table - use database values
            const topicsTable = document.getElementById('topics-table').querySelector('tbody');
            data.topics.forEach(topic => {
                const area = data.areas.find(a => a.id === topic.areaId);
                const connections = topic.connectionCount || 0;
                const totalStrength = topic.totalConnectionStrength || 0;
                const row = document.createElement('tr');
                row.dataset.course = topic.areaId;
                if (connections === 0) {
                    row.classList.add('no-connections');
                }
                row.innerHTML = `
                    <td>
                        <span class="color-dot" style="background: ${area ? area.color : '#888'};"></span>
                        ${area ? area.name : 'Unknown'}
                    </td>
                    <td>
                        <strong>${topic.name}</strong>
                        ${connections === 0 ? '<span class="no-connections-badge">No Connections</span>' : ''}
                    </td>
                    <td>${topic.description}</td>
                    <td>${connections}</td>
                    <td><strong>${totalStrength}</strong></td>
                `;
                topicsTable.appendChild(row);
            });

            // Relationships table
            const relTable = document.getElementById('relationships-table').querySelector('tbody');
            data.relationships.forEach(rel => {
                const source = data.topics.find(t => t.id === rel.source);
                const target = data.topics.find(t => t.id === rel.target);
                const row = document.createElement('tr');
                row.dataset.strength = rel.strength;
                row.innerHTML = `
                    <td>${source.name}</td>
                    <td>${target.name}</td>
                    <td>${rel.strength}/10</td>
                    <td>${rel.reason}</td>
                `;
                relTable.appendChild(row);
            });
        }

        function filterTable() {
            const courseFilter = document.getElementById('course-filter').value;
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            const rows = document.querySelectorAll('#topics-table tbody tr');

            rows.forEach(row => {
                const matchesCourse = courseFilter === 'all' || row.dataset.course === courseFilter;
                const matchesSearch = searchTerm === '' || row.textContent.toLowerCase().includes(searchTerm);
                row.style.display = (matchesCourse && matchesSearch) ? '' : 'none';
            });
        }

        function filterRelationships() {
            const minStrength = parseInt(document.getElementById('strength-filter').value);
            const rows = document.querySelectorAll('#relationships-table tbody tr');

            rows.forEach(row => {
                const strength = parseInt(row.dataset.strength);
                row.style.display = strength >= minStrength ? '' : 'none';
            });
        }

        // Filtering functions
        function toggleCourse(courseId) {
            if (activeCourses.has(courseId)) {
                activeCourses.delete(courseId);
                d3.select(`.legend-item[data-course="${courseId}"]`).classed('dimmed', true);
            } else {
                activeCourses.add(courseId);
                d3.select(`.legend-item[data-course="${courseId}"]`).classed('dimmed', false);
            }
            updateGraphFilters();

            // Center view after course toggle
            setTimeout(() => {
                if (window.centerOnNodes) {
                    window.centerOnNodes(1500);
                }
            }, 1000);
        }


        function updateGraphFilters() {
            if (!graphElements.link) return;

            const { link, node, particles, g, allLinks } = graphElements;
            const nodes = window.graphNodes; // Use globally stored nodes

            // Filter links by strength and active courses (nodes already filtered)
            const filteredLinks = allLinks.filter(d => {
                const sourceNode = nodes.find(t => t.id === d.source.id || t.id === d.source);
                const targetNode = nodes.find(t => t.id === d.target.id || t.id === d.target);
                const sourceCourse = sourceNode ? sourceNode.areaId : null;
                const targetCourse = targetNode ? targetNode.areaId : null;

                return d.strength >= minStrength &&
                       sourceNode &&
                       targetNode &&
                       activeCourses.has(sourceCourse) &&
                       activeCourses.has(targetCourse);
            });

            // Smoothly fade links in/out
            link.transition()
                .duration(800)
                .style('opacity', d => {
                    const sourceNode = nodes.find(t => t.id === d.source.id);
                    const targetNode = nodes.find(t => t.id === d.target.id);
                    const show = sourceNode && targetNode &&
                                d.strength >= minStrength &&
                                activeCourses.has(sourceNode.areaId) &&
                                activeCourses.has(targetNode.areaId);
                    return show ? 1 : 0;
                })
                .on('end', function(d) {
                    const sourceNode = nodes.find(t => t.id === d.source.id);
                    const targetNode = nodes.find(t => t.id === d.target.id);
                    const show = sourceNode && targetNode &&
                                d.strength >= minStrength &&
                                activeCourses.has(sourceNode.areaId) &&
                                activeCourses.has(targetNode.areaId);
                    d3.select(this).style('display', show ? 'block' : 'none');
                });

            // Count active connections for each node after filtering
            const activeConnectionCounts = {};
            nodes.forEach(n => activeConnectionCounts[n.id] = 0);
            filteredLinks.forEach(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;
                activeConnectionCounts[sourceId] = (activeConnectionCounts[sourceId] || 0) + 1;
                activeConnectionCounts[targetId] = (activeConnectionCounts[targetId] || 0) + 1;
            });

            // Smoothly fade nodes in/out - hide if not in active course OR has no active connections after filtering
            node.transition()
                .duration(800)
                .style('opacity', d => {
                    const inActiveCourse = activeCourses.has(d.areaId);
                    const hasActiveConnections = (activeConnectionCounts[d.id] || 0) > 0;
                    return (inActiveCourse && hasActiveConnections) ? 1 : 0;
                })
                .on('end', function(d) {
                    const inActiveCourse = activeCourses.has(d.areaId);
                    const hasActiveConnections = (activeConnectionCounts[d.id] || 0) > 0;
                    d3.select(this).style('display', (inActiveCourse && hasActiveConnections) ? 'block' : 'none');
                });

            // Smoothly fade particles in/out
            particles.transition()
                .duration(800)
                .style('opacity', (d, i) => {
                    const linkData = d.link;
                    const sourceNode = nodes.find(t => t.id === linkData.source.id);
                    const targetNode = nodes.find(t => t.id === linkData.target.id);
                    const show = sourceNode && targetNode &&
                                linkData.strength >= minStrength &&
                                activeCourses.has(sourceNode.areaId) &&
                                activeCourses.has(targetNode.areaId);
                    return show ? 0.5 : 0;
                });

            // Update simulation with filtered links
            simulation.force('link').links(filteredLinks);

            // Smoothly recalculate positions
            const simNodes = simulation.nodes();
            const oldTargets = new Map();
            simNodes.forEach(n => {
                oldTargets.set(n.id, { x: n.targetX, y: n.targetY });
            });

            // Calculate new positions
            simulation.alpha(0.5);
            for (let i = 0; i < 150; i++) {
                simulation.tick();
            }

            // Store new targets and create smooth transition
            simNodes.forEach(n => {
                const old = oldTargets.get(n.id);
                const newTargetX = n.x;
                const newTargetY = n.y;

                // Reset to old position
                n.targetX = old.x;
                n.targetY = old.y;

                // Animate to new position over time
                const duration = 2000; // 2 seconds smooth transition
                const startTime = Date.now();

                function transitionPosition() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = easeInOutCubic(progress);

                    n.targetX = old.x + (newTargetX - old.x) * eased;
                    n.targetY = old.y + (newTargetY - old.y) * eased;

                    if (progress < 1) {
                        requestAnimationFrame(transitionPosition);
                    }
                }
                transitionPosition();
            });

            simulation.alpha(0.1).restart();
        }

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        // Start
        init();
    </script>
</body>
</html>
